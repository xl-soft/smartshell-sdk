есть функция `node<T = Node | Child>(name: string) => T` которая возвращает следующие данные 

type Node = { key: string, value: string[], scalar: boolean, child?: Node[] | Child }
type Child = { type: 'union' | 'enum' | 'ERROR', value: string[] }


и уже существующий код

const parent = node<Node[]>(name)
const filtered = []
const result = []
let level = 0
for (let i = 0; i < parent.length; i++) {
    const item: Node = parent![i];
    const paginated = item.key === "paginatorInfo"
    if (paginated) continue
    filtered.push(item)
}

for (let i = 0; i < filtered.length; i++) {
    const item = filtered[i];
    if (item.scalar) { result.push(item); continue }
    else {
        item.child = node(item.value[0])

        for (let j = 0; j < item.child!.length; j++) {
            if (item.child[j].scalar) continue 
            item.child[j].child = node(item.child[j].value[0])
            for (let k = 0; k < item.child[j].child.length; k++) {
                const grandchild_node = node(item.child[j].child[k].value[0])
                if (item.child[j].child[k].value[0])
                if (!grandchild_node || String(grandchild_node) === '[object Object]') continue
                const infertile = grandchild_node.map(o => o.scalar === true).includes(false)
                if (infertile) continue
                item.child[j].child[k].child = grandchild_node
            }
        }
    }
    result.push(item)
}
console.log(JSON.stringify(result, null, 4))

оптимизируй его












































задача кода, обработать дерево по следующим правилам

задаем уровень обработки
let level = 0

получаем родителя
const name = 'clients'
const root = node<Node>(name)
let root_filtered

на этом этапе в root мы гарантированно получаем тип `Node`
проходимся по всем значениям родителя
если в root есть объекты с key равным 'data' и 'paginatorInfo' значит мы находимся внутри пагинатора
если root - пагинатор, значит мы не считаем его истинным, фильтруем root удаляя объект с key = 'paginatorInfo' и записываем в root_filtered, а так же поднимаемся на уровень выше `level--`
если root не пагинатор то записываем все в root_filtered и остаемся на 0 уровне

начинаем обрабатывать наше дерево
const root = root_filtered

-1 по 1 уровень

проходимся по каждому элементу, 
если scalar = true, или элемент является обьектом с типом Child и полем type = 'enum', пропускаем, иначе в поле child записываем результат функции node с переданным полем value[0]
если элемент имеет поле value равное родителю выше значит значение зацикленное и элемент мы пропускаем 
если scalar = false и элемент не является зацикленным то спускаемся на уровень ниже

2+ уровень

проходимся по каждому элементу, если scalar = true, или элемент является не массивом а объектом, пропускаем, иначе начинаем новую проверку "infertile". Задача этой проверки, понять могут ли у элемента быть дети c типом Node
для этого делаем `.map(o => o.scalar === true || String(node(o.value[0])) !== '[object Object]').includes(false)`
если элемент имеет поле value равное родителю выше значит значение зацикленное и элемент мы пропускаем 
если scalar = false и элемент не является зацикленным 






проходимся по каждому значению root и fakeroot поля если значение тупиковое а именно SCALAR выделяем его
если значение не тупиковое, выделяем внутри все поля которые являются тупиковыми, если поле не тупиковое но в нем абсолютно все поля тупиковые то выделяем все
дальше 3 уровня не идем

вложенные обьекты делаются функцией key()

помимо обьектов и тупиков есть еще union это обьединенные несколько типов в один название которого надо добавить в import.gql

{
    "name": "CommentEntity",
    "kind": "UNION",
    "inputFields": [],
    "enumValues": [],
    "possibleTypes": [
        {
            "name": "User"
        },
        {
            "name": "Host"
        },
        {
            "name": "ClientSession"
        }
    ],
    "fields": []
},

в possibleTypes могут быть несколько типов, проходимся по им всем и выделяем все тупиковые значения, глубже не идем

