есть функция `node<T = Node | Child>(name: string) => T` которая возвращает следующие данные 

type Node = { key: string, value: string[], required: boolean, array: boolean, scalar: boolean, child?: Node[] | Child }[]
type Child = { type: 'union' | 'enum' | 'ERROR', value: string[] }

задача кода, обработать дерево по следующим правилам

получаем родителя 
const name = 'clients'
const parent = node<Node>(name)

на этом этапе мы гарантированно получаем тип Node 

проходимся по всем значениям родителя



давай добавим функцию const structure = (name: string) => string
в name будет передаваться название корневого типа 

используй модуль typescript из npm и импортируй его следующим образом "import ts from "npm:typescript"
вытащи строку файла с типами, пропарси типы и работай с ними

есть несколько видов типов:
тупиковые - это те которые являются обычными типами TypeScript number, string
и те названия которых записаны в const deadend
в них нет никакой вложенности

юнионы - обьединенные типы из нескольких штук обьектов, они обозначаются как export type UnionType = Type & SomeType & SomeOtherType

и обьекты, они обрабатываются по следующим правилом

пример 1
export type UserPaginated = { // FakeRoot - уровень 0, реальный корень, считаем фейком так как есть пагинатор и поле data
    paginatorInfo?: PaginatorInfo // пропущен
    data: User[] // выделен, вложенный, Root - уровень 1, корень который нам нужен
    total_deposits?: number // выделен, тупиковый
}
пример 2
export type EventListItemCashOrder = { // Root - уровень 1, считаем нужным нам корнем ведь у него нет ни пагинатора ни поля data
    id?: number // выделен, тупиковый
    created_at?: DateTime // выделен, тупиковый
    type?: CashOrderType // выделен, вложенный
    sum?: number // выделен, тупиковый
    comment?: string // выделен, тупиковый
}

на 1 уровне выбираем все тупиковые типы и поле data если оно есть paginatorInfo пропускаем всегда и везде

проходимся по каждому названию типа на 1 уровне. если значение тупиковое выделяем его если значение не тупиковое, 
спускаемся на 2 уровень выделяем внутри все поля которые являются тупиковыми, если поле не тупиковое но на 3 уровне в нем абсолютно все поля тупиковые то выделяем все
дальше 3 уровня не идем
union тип является своего рода массивом, проходимся по каждому типу в юнион и выделяем в них только тупиковые типы

теперь о том куда все это будет сохранятся

нам надо вернуть строку которая следуюет правилам выше и форматирована следующим образом

так будет выглядеть тип со всеми тупиковыми полями
`[
	"token_type",
	"access_token",
	"refresh_token",
	"expires_in"
]`
так будет выглядить с вложенным полем
`[
	"token_type",
	"access_token",
	"refresh_token",
	"expires_in"
    key("token_info", [
        "created",
        "updated",
    ])
]`

так будет выглядить с вложенным полями с 3 уровнями
`[
	"token_type",
	"access_token",
	"refresh_token",
	"expires_in"
    key("token_info", [
        "created",
        "updated",
        key("creator", [
            "id",
            "name",
        ])
    ])
]`

так будет выглядить с вложенным полями с 3 уровнями и union

`[
	"token_type",
	"access_token",
	"refresh_token",
	"expires_in"
    key("token_info", [
        "created",
        "updated",
        key("creator", [
            "id",
            "name",
            on('entity', [
                { on: 'User', with: [
                    "id",
                    "uuid",
                    "login",
                    "nickname",
                ]},
                { on: 'Host', with: [
                    "id",
                    "group_id",
                    "type_id",
                    "position",
                ]},
                { on: 'ClientSession', with: [
                    "id",
                    "duration",
                    "elapsed",
                    "postpaid",
                    "total_cost",
                ]},
            ]),
        ])
    ])
]`
